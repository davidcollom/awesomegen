package render

import (
	"fmt"
	"maps"
	"slices"
	"strings"

	"github.com/davidcollom/awesomegen/internal/config"
	"github.com/davidcollom/awesomegen/internal/github"
)

func Markdown(list config.List) string {
	var b strings.Builder

	// Header
	fmt.Fprintf(&b, "# %s\n\n", list.Title)
	if len(list.Badges) > 0 {
		for _, u := range list.Badges {
			fmt.Fprintf(&b, "![badge](%s) ", u)
		}
		b.WriteString("\n\n")
	}
	if list.Tagline != "" {
		fmt.Fprintf(&b, "> %s\n\n", list.Tagline)
	}

	writeByTopTags(&b, list)

	b.WriteString("\n---\n\n")
	b.WriteString("*Generated by [awesomegen](https://github.com/davidcollom/awesomegen).*")
	b.WriteString("\n")

	return b.String()
}

func writeByTopTags(b *strings.Builder, list config.List) {
	var items []config.Item
	for _, c := range list.Categories {
		items = append(items, c.Items...)
	}

	ranked := rankTopTags(items, list.TagAliases, list.MinTagCount, list.TopTagsLimit)
	if len(ranked) == 0 {
		b.WriteString("_No topics found._\n")
		return
	}

	if list.TopicGroupingMode == "nested" {
		nested := map[string]map[string][]config.Item{}
		for _, it := range items {
			if it.GHMeta == nil {
				continue
			}
			p, s := primarySecondaryForRepo(it.GHMeta, ranked, list.TagAliases, list.TopicFallback)
			if _, ok := nested[p]; !ok {
				nested[p] = map[string][]config.Item{}
			}
			nested[p][s] = append(nested[p][s], it)
		}

		// TOC
		prim := mapsSortedKeysNested(nested)
		b.WriteString("## Table of Contents\n")
		for _, pk := range prim {
			fmt.Fprintf(b, "- [%s](#%s)\n", pk, slug(pk))
		}
		b.WriteString("\n")

		for _, pk := range prim {
			fmt.Fprintf(b, "## %s\n\n", pk)
			sec := nested[pk]
			sk := mapsSortedKeys(sec)
			for _, s := range sk {
				if s != list.TopicFallback || len(sec) > 1 {
					fmt.Fprintf(b, "### %s\n\n", s)
				}
				writeRepoLines(b, sec[s], list)
				b.WriteString("\n")
			}
		}
		return
	}

	// flat mode
	groups := map[string][]config.Item{}
	for _, it := range items {
		if it.GHMeta == nil {
			continue
		}
		p, _ := primarySecondaryForRepo(it.GHMeta, ranked, list.TagAliases, list.TopicFallback)
		groups[p] = append(groups[p], it)
	}

	keys := mapsSortedKeys(groups)
	b.WriteString("## Table of Contents\n")
	for _, k := range keys {
		fmt.Fprintf(b, "- [%s](#%s)\n", k, slug(k))
	}
	b.WriteString("\n")

	for _, k := range keys {
		fmt.Fprintf(b, "## %s\n\n", k)
		writeRepoLines(b, groups[k], list)
		b.WriteString("\n")
	}
}

func writeFlatByTopic(b *strings.Builder, list config.List) {
	groups := map[string][]config.Item{}
	for _, c := range list.Categories {
		for _, it := range c.Items {
			if it.GHMeta == nil {
				continue
			}
			t := list.TopicFallback
			if len(it.GHMeta.Topics) > 0 && it.GHMeta.Topics[0] != "" {
				t = it.GHMeta.Topics[0]
			}
			groups[t] = append(groups[t], it)
		}
	}
	// TOC
	b.WriteString("## Table of Contents\n")
	keys := mapsSortedKeys(groups)
	for _, k := range keys {
		fmt.Fprintf(b, "- [%s](#%s)\n", k, slug(k))
	}
	b.WriteString("\n")
	// Sections
	for _, k := range keys {
		fmt.Fprintf(b, "## %s\n\n", k)
		writeRepoLines(b, groups[k], list)
		b.WriteString("\n")
	}
}

func writeNestedByTopic(b *strings.Builder, list config.List) {
	nested := map[string]map[string][]config.Item{}
	for _, c := range list.Categories {
		for _, it := range c.Items {
			if it.GHMeta == nil {
				continue
			}
			topics := it.GHMeta.Topics
			primary := list.TopicFallback
			if len(topics) > 0 && topics[0] != "" {
				primary = topics[0]
			}
			secondary := list.TopicFallback
			if len(topics) > 1 && topics[1] != "" {
				secondary = topics[1]
			}

			if _, ok := nested[primary]; !ok {
				nested[primary] = map[string][]config.Item{}
			}
			nested[primary][secondary] = append(nested[primary][secondary], it)
		}
	}

	// TOC (primary only to avoid clutter)
	b.WriteString("## Table of Contents\n")
	primKeys := mapsSortedKeysNested(nested)
	for _, pk := range primKeys {
		fmt.Fprintf(b, "- [%s](#%s)\n", pk, slug(pk))
	}
	b.WriteString("\n")

	for _, pk := range primKeys {
		fmt.Fprintf(b, "## %s\n\n", pk)
		sec := nested[pk]
		secKeys := mapsSortedKeys(sec)
		for _, sk := range secKeys {
			// Skip if primary==secondary and it would look redundant? Keep simple for now.
			fmt.Fprintf(b, "### %s\n\n", sk)
			writeRepoLines(b, sec[sk], list)
			b.WriteString("\n")
		}
	}
}

func writeFlatUnGrouped(b *strings.Builder, list config.List) {
	b.WriteString("## Repositories\n\n")
	if len(list.Categories) == 0 {
		return
	}
	writeRepoLines(b, list.Categories[0].Items, list)
	b.WriteString("\n")
}

func writeRepoLines(b *strings.Builder, items []config.Item, list config.List) {
	// keep sort stable & readable
	slices.SortFunc(items, func(a, b config.Item) int {
		var ak, bk string
		if a.GHMeta != nil {
			ak = a.GHMeta.FullName
		}
		if b.GHMeta != nil {
			bk = b.GHMeta.FullName
		}
		switch {
		case ak < bk:
			return -1
		case ak > bk:
			return 1
		default:
			return 0
		}
	})
	for _, it := range items {
		m := it.GHMeta
		if m == nil {
			continue
		}
		// stars (humanised, optional)
		stars := humanStars(m.Stars, list.StarsFormat, list.Locale)
		starPart := ""
		if stars != "" {
			starPart = " — ⭐ " + stars
		}

		license := ""
		if m.License != "" {
			license = " · " + m.License
		}

		note := ""
		if it.Notes != "" {
			note = " — " + it.Notes
		}

		desc := strings.TrimSpace(m.Description)
		fmt.Fprintf(b, "- [%s](%s)%s%s — %s%s\n",
			m.FullName, m.URL, starPart, license, desc, note)
	}
}

func mapsSortedKeys[T any](m map[string]T) []string {
	keys := slices.Collect(maps.Keys(m))
	slices.Sort(keys)
	return keys
}

func mapsSortedKeysNested(m map[string]map[string][]config.Item) []string {
	keys := slices.Collect(maps.Keys(m))
	slices.Sort(keys)
	return keys
}

func primarySecondaryForRepo(m *github.RepoMeta, ranked []string, aliases map[string]string, fallback string) (string, string) {
	if m == nil {
		return fallback, fallback
	}
	// Build the set of this repo's canonical tags
	rtags := make([]string, 0, len(m.Topics))
	seen := map[string]struct{}{}
	for _, raw := range m.Topics {
		t := canonicalTag(raw, aliases)
		if t == "" {
			continue
		}
		if _, ok := seen[t]; ok {
			continue
		}
		seen[t] = struct{}{}
		rtags = append(rtags, t)
	}
	// primary = first tag that appears in ranked order
	primary := fallback
	for _, t := range ranked {
		for _, rt := range rtags {
			if rt == t {
				primary = t
				goto foundPrimary
			}
		}
	}
foundPrimary:
	// secondary = next ranked tag (distinct), else fallback
	secondary := fallback
	if primary != fallback {
		for _, t := range ranked {
			if t == primary {
				continue
			}
			for _, rt := range rtags {
				if rt == t {
					secondary = t
					goto foundSecondary
				}
			}
		}
	}
foundSecondary:
	return primary, secondary
}
